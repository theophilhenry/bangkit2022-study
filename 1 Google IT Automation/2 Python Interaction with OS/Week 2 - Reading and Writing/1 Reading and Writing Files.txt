== Reading Files ==
to open spider.txt use this 
>>> file = open("spider.txt")
When we open file, the OS give permissions. And give our code a "File Descriptor".
File Descriptor : Token generated by OS to allow programs do more operations
This FD stored as an attribute in the file var. 

>>> print(file.readline())
Each readline(), the object update current position of the file.

>> print(file.readlines())
return all lines in list

>>> print(file.read())
Read goes to the end of the file, instead of one line.

Be careful when reading the entire contents, it can take a log of computer's memory to hold it, which leads to poor performance.

>>> file.close()
We close the file using this.
Why?
First, when script open file, the system usually locks it. No other programs/script can access it.
Second, There are limited number of File Descriptors. 
Third, leaving file can lead to race conditions which occur when multiple processes try to modify/read from one resource at the same time.

It is hard to remember close file right?
>>> with open("spider.txt") as file:
This way, it automatically closes when the code blocks end.

== Iterating Files ==
with open("spider.txt") as file:
    for line in file:
    print(line.strip())


== Writing Files ==
with open("new_file.txt", "w") as file:
    file.write("Hello")

File can be opened with different Mode. It is similar to file permission. 
By default open uses r mode (readonly)
w: write it. if the file doesn't exists python will create it, if it does exists, the current contests will be overwritten.
a: appending content to a file that already exists.
r+: read and write mode

Btw, when write is success, it returns number of character that it wrote. 